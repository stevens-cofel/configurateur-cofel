<!DOCTYPE html>
<html lang="fr">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../styles/cofel.css">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <div style="background:#003366; padding:10px;">
  <a href="../index.html" style="
    color:white;
    text-decoration:none;
    font-weight:bold;
    font-family:Arial, sans-serif;
    background:#0055aa;
    padding:8px 14px;
    border-radius:6px;
    display:inline-block;
  ">
    ⬅ Retour aux configurateurs
  </a>
</div>

<title>Configurateur Lettres Boîtiers - Cofel</title>
<style>
  :root{
    --bg:#f7f7f7; --txt:#333;
    --card:#fff; --bd:#e6e6e6; --bd2:#d7d7d7;
    --shadow:0 10px 28px rgba(0,0,0,.08);
    --info-bg:#e9f5ff; --info-bd:#b3e0ff;
    --pill-bg:#f0f3f9; --pill-bd:#e5e9f3;
  }
  *{box-sizing:border-box}
  body{font-family:Arial, sans-serif;background:var(--bg);margin:0;padding:24px;color:var(--txt)}
  h1{text-align:center;margin:0 0 16px}
  .wrap{max-width:980px;margin:0 auto;background:var(--card);border-radius:12px;box-shadow:var(--shadow);padding:24px}
  label{display:block;margin-top:14px;font-weight:700}
  input,select{width:100%;padding:10px;margin-top:6px;border:1px solid var(--bd2);border-radius:8px;min-height:44px}
  input[type="number"]{appearance:textfield}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  @media (max-width:820px){ .grid{grid-template-columns:1fr} }
  .help{font-size:12px;color:#555;margin-top:6px}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:var(--pill-bg);color:#444;font-size:12px;border:1px solid var(--pill-bd);margin:6px 6px 0 0}
  .result{margin-top:22px;padding:16px;background:var(--info-bg);border:1px solid var(--info-bd);border-radius:10px;font-size:18px;text-align:center}
  .muted{color:#666;font-size:12px;margin-top:8px;white-space:pre-wrap}
  .diag{margin-top:12px;border:1px dashed #ccc;border-radius:10px;padding:10px;background:#fafafa;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;font-size:12px;display:none}
</style>
</head>
<body>
<h1>Configurateur Lettres Boîtiers - Cofel</h1>

<div class="wrap">
  <div class="grid">
    <div>
      <label for="famille">Type de lettre boîtier</label>
      <select id="famille"><option value="">— sélectionnez —</option></select>
    </div>
    <div>
      <label for="quantite">Quantité</label>
      <input type="number" id="quantite" value="1" min="1"/>
    </div>
  </div>

  <div class="grid">
    <div>
      <label for="hauteur">Hauteur (mm)</label>
      <input type="number" id="hauteur" placeholder="Ex : 325" min="1"/>
      <div id="rangesHelp" class="help"></div>
    </div>
    <div>
      <label for="variant">Eclairage (si présent)</label>
      <select id="variant"><option value="">— (aucun filtre) —</option></select>
      <div class="help" id="variantHelp"></div>
    </div>
  </div>

  <div class="result">
    <p>Prix HT : <span id="prixHT">0,00</span> €</p>
    <p>Prix TTC : <span id="prixTTC">0,00</span> €</p>
  </div>

  <label style="margin-top:14px;display:flex;align-items:center;gap:8px;font-weight:normal">
    <input type="checkbox" id="toggleDiag"/> Afficher le diagnostic (débogage)
  </label>
  <div id="diag" class="diag"></div>

  <div id="msg" class="muted"></div>
</div>

<script>
/* =======================
   CONFIG
   ======================= */
const TVA = 0.20;
const FAMILLES = [
  {
    name: "Boîtier Bâton – face PMMA blanc diffusant",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/lettre%20boitier%20baton%20chants%20alu%20laqu%C3%A9%20et%20face%20PMMA%20blanc%20diffusant.csv"
  },
  {
    name: "Boîtier Bâton – face Dibond",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20laqu%C3%A9e%20B%C3%A2ton%20chants%20aluminium%20et%20face%20avant%20type%20Dibond.csv"
  },
  {
    name: "Boîtier Fantaisie – face Dibond",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20laqu%C3%A9e%20Fantaisie%20chants%20aluminium%20et%20face%20avant%20type%20Dibond.csv"
  },
  {
    name: "Boîtier Fantaisie – face PMMA blanc diffusant",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20Fantaisie%20chants%20laqu%C3%A9s%20et%20faces%20PMMA%20blanc%20diffusant.csv"
  }
];

/* =======================
   STATE & ELEMENTS
   ======================= */
let CURRENT = null; // {name,url}
let HEADS = [];
let ROWS = [];
let MAP = null;     // {hminKey,hmaxKey,baseKey,variantKey}

const elFam = document.getElementById('famille');
const elQ   = document.getElementById('quantite');
const elH   = document.getElementById('hauteur');
const elVar = document.getElementById('variant');
const elVarHelp = document.getElementById('variantHelp');
const elRanges = document.getElementById('rangesHelp');
const elHT  = document.getElementById('prixHT');
const elTTC = document.getElementById('prixTTC');
const elMsg = document.getElementById('msg');
const elDiag= document.getElementById('diag');
const elTgD = document.getElementById('toggleDiag');

/* =======================
   HELPERS
   ======================= */
function normKey(k){
  return String(k||'').toLowerCase()
   .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
   .replace(/[^a-z0-9]+/g,'').trim();
}
function numFR(v){
  if(v===null||v===undefined) return NaN;
  let s = String(v).trim().replace(/€/g,'').replace(/[\u00A0\u202F]/g,'');
  if(s.includes(',') && s.includes('.')) s = s.replace(/\./g,'');
  s = s.replace(',', '.');
  const m = s.match(/-?\d+(\.\d+)?/);
  return m ? parseFloat(m[0]) : NaN;
}
function euro(n){ return (isFinite(n)?n:0).toFixed(2).replace('.', ','); }

/* ===== CSV Parser robuste (guillemets, virgules/points-virgules, “double quotes”) ===== */
function parseCSVLine(line, sep=','){
  const out=[]; let cur=''; let inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i], nx=line[i+1];
    if(ch==='"'){
      if(inQ && nx==='"'){ cur+='"'; i++; }
      else inQ=!inQ;
    }else if(ch===sep && !inQ){
      out.push(cur); cur='';
    }else{
      cur+=ch;
    }
  }
  out.push(cur);
  return out;
}
// Normalise les CSV “encapsulés” (entièrement entre guillemets avec doublements)
function normalizeWeirdCSV(text){
  let t = text.replace(/^\uFEFF/,'').replace(/\r/g,'');
  // S'il y a beaucoup de guillemets et peu de retours, on reconstruit
  const manyQuotes = (t.match(/"/g)||[]).length > 50;
  const fewNewlines = (t.match(/\n/g)||[]).length < 3;
  if(manyQuotes && fewNewlines){
    t = t.replace(/""/g,'"');
    const blocks=[]; const re=/"([^"]*)"/g; let m;
    while((m=re.exec(t))!==null){ blocks.push(m[1]); }
    if(!blocks.length) return text;
    const cols = parseCSVLine(blocks[0], ',').length;
    const lines=[];
    for(let i=0;i<blocks.length;i+=cols){
      lines.push(blocks.slice(i,i+cols).map(s=>`"${s}"`).join(','));
    }
    return lines.join('\n');
  }
  // Retire guillemets d'enrobage ligne à ligne si présents
  return t.split('\n').map(l=>{
    const s=l.trim();
    if(s.startsWith('"') && s.endsWith('"')) return s.slice(1,-1);
    return s;
  }).join('\n');
}
function parseCSVAuto(text){
  const norm = normalizeWeirdCSV(text);
  const lines = norm.split('\n').filter(l=>l.trim()!=='');
  if(!lines.length) return {rawHeads:[],rows:[]};
  const first = lines[0];
  const sep = (first.match(/;/g)||[]).length > (first.match(/,/g)||[]).length ? ';' : ',';
  const rawHeads = parseCSVLine(lines[0], sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
  const rows = lines.slice(1).map(line=>{
    const cells = parseCSVLine(line, sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
    const o={}; rawHeads.forEach((h,i)=>o[h]=cells[i]??''); return o;
  });
  return {rawHeads, rows};
}

/* ===== Mapping automatique des colonnes selon tes entêtes ===== */
function buildMapping(rawHeads){
  const NK = rawHeads.map(normKey);
  const findExact = (nkWanted)=> {
    const idx = NK.findIndex(k=>k===nkWanted);
    return idx>=0 ? rawHeads[idx] : null;
  };
  const findLoose = (reArr)=> {
    for(let i=0;i<NK.length;i++){
      const k=NK[i];
      if(reArr.every(re=>re.test(k))) return rawHeads[i];
    }
    return null;
  };

  // D'après ton en-tête : HauteurMin_mm, HauteurMax_mm, PrixUnitaire_EUR, Eclairage
  const hminKey = findExact('hauteurminmm') || findLoose([/hauteur/,/min/]);
  const hmaxKey = findExact('hauteurmaxmm') || findLoose([/hauteur/,/max/]);
  const baseKey = findExact('prixunitaireeur') || findLoose([/prix|tarif/,/eur|ht|unitaire/]);
  const variantKey = findExact('eclairage') || findLoose([/eclairage|eclair|led/]);

  return { hminKey, hmaxKey, baseKey, variantKey };
}

/* ===== UI helpers ===== */
function fillFamilles(){
  famille.innerHTML = '<option value="">— sélectionnez —</option>' +
    FAMILLES.map((f,i)=>`<option value="${i}">${f.name}</option>`).join('');
}
function buildVariantUI(){
  variant.innerHTML = '<option value="">— (aucun filtre) —</option>';
  variantHelp.textContent = '';
  if(!MAP?.variantKey) return;
  const key = MAP.variantKey;
  const values = [...new Set(ROWS.map(r=>String(r[key]||'').trim()).filter(Boolean))].sort();
  if(!values.length) return;
  variant.innerHTML = '<option value="">— sélectionnez —</option>' +
    values.map(v=>`<option value="${v}">${v}</option>`).join('');
  variantHelp.textContent = `Filtre sur « ${key} ».`;
}
function buildRangesHelp(){
  if(!MAP?.hmaxKey){ rangesHelp.textContent=''; return; }
  const kmin = MAP.hminKey, kmax = MAP.hmaxKey;
  const pills=[]; const seen=new Set();
  for(const r of ROWS){
    const a = numFR(kmin? r[kmin] : 0);
    const b = numFR(r[kmax]);
    if(!Number.isFinite(b)) continue;
    const txt = (Number.isFinite(a) && a>0) ? `${a}–${b}` : `≤ ${b}`;
    if(!seen.has(txt)){ pills.push(txt); seen.add(txt); }
  }
  pills.sort((A,B)=> Number(A.replace(/[^\d]/g,'')) - Number(B.replace(/[^\d]/g,'')));
  rangesHelp.innerHTML = pills.map(p=>`<span class="pill">${p}</span>`).join('');
}

/* ===== Cœur du calcul ===== */
function filterRowsByVariant(rows){
  if(!MAP?.variantKey) return rows;
  const v = variant.value;
  if(!v) return rows;
  return rows.filter(r => String(r[MAP.variantKey]||'').trim() === v);
}
function findRowForHeight(H){
  const kmin = MAP.hminKey, kmax = MAP.hmaxKey;
  let rows = filterRowsByVariant(ROWS);
  if(!rows.length) return null;

  rows = rows.slice().sort((a,b)=>{
    const amin = numFR(kmin ? a[kmin] : 0), amax = numFR(a[kmax]);
    const bmin = numFR(kmin ? b[kmin] : 0), bmax = numFR(b[kmax]);
    if(amin!==bmin) return amin-bmin;
    return amax-bmax;
  });

  // première tranche sans min : H <= max
  const first = rows[0];
  const firstMax = numFR(first[kmax]);
  if(Number.isFinite(firstMax) && H <= firstMax) return first;

  // tranche [min,max]
  for(const r of rows){
    const a = numFR(kmin ? r[kmin] : 0);
    const b = numFR(r[kmax]);
    if(Number.isFinite(a) && Number.isFinite(b) && H>=a && H<=b) return r;
  }

  // au-delà : dernière tranche
  return rows[rows.length-1] || null;
}
function compute(){
  const H = Number(hauteur.value||0);
  const Q = Math.max(1, Number(quantite.value||1));
  if(!(H>0) || !ROWS.length || !MAP?.hmaxKey || !MAP?.baseKey){
    prixHT.textContent='0,00'; prixTTC.textContent='0,00';
    renderDiag(null,H,Q); return;
  }
  const row = findRowForHeight(H);
  const base = row ? numFR(row[MAP.baseKey]) : 0;
  const totalHT = (base || 0) * Q;
  const totalTTC = totalHT * (1+TVA);
  prixHT.textContent = euro(totalHT);
  prixTTC.textContent = euro(totalTTC);
  renderDiag(row,H,Q,base,totalHT,totalTTC);
}
function renderDiag(row,H,Q,base=0,tHT=0,tTTC=0){
  if(!toggleDiag.checked){ diag.style.display='none'; return; }
  diag.style.display='block';
  if(!row){
    diag.textContent = `DIAG: H=${H} | lignes=${ROWS.length}\n→ Saisir une hauteur et choisir une famille.`;
    return;
  }
  const seg = [
    `Famille: ${CURRENT?.name||''}`,
    `Hauteur saisie: ${H} → tranche: [${MAP.hminKey? row[MAP.hminKey] : '0'} … ${row[MAP.hmaxKey]}]`,
    `Prix unitaire: ${euro(base)} € | Qté: ${Q}`,
    `TOTAL HT: ${euro(tHT)} € | TTC: ${euro(tTTC)} €`
  ];
  if(MAP?.variantKey){
    seg.splice(1,0,`Filtre ${MAP.variantKey}: ${variant.value||'(aucun)'}`);
  }
  diag.textContent = seg.join('\n');
}

/* ===== LOADERS ===== */
async function fetchText(u){
  const r = await fetch(u, {cache:'no-store'});
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.text();
}
async function loadFamily(f){
  const txt = await fetchText(f.url);
  const parsed = parseCSVAuto(txt);
  HEADS = parsed.rawHeads;
  ROWS  = parsed.rows;
  MAP   = buildMapping(HEADS);

  buildVariantUI();
  buildRangesHelp();

  msg.textContent = `Fichier chargé: ${f.name}
En-têtes: ${HEADS.join(' | ')}
Colonnes → HauteurMin: ${MAP.hminKey||'n/a'} | HauteurMax: ${MAP.hmaxKey||'n/a'} | Prix: ${MAP.baseKey||'n/a'} | Variante: ${MAP.variantKey||'n/a'}`;
}

/* ===== INIT & BIND ===== */
function bind(){
  famille.addEventListener('change', async ()=>{
    const i = parseInt(famille.value,10);
    if(isNaN(i)){ CURRENT=null; ROWS=[]; MAP=null; compute(); return; }
    CURRENT = FAMILLES[i];
    msg.textContent = 'Chargement…';
    try{
      await loadFamily(CURRENT);
      msg.textContent += '\nPrêt.';
      compute();
    }catch(e){
      console.error(e);
      msg.textContent = 'Erreur de chargement: '+e.message;
    }
  });
  quantite.addEventListener('input', compute);
  hauteur.addEventListener('input', compute);
  variant.addEventListener('change', compute);
  toggleDiag.addEventListener('change', compute);
}
(function init(){ fillFamilles(); bind(); })();
</script>
</body>
</html>


