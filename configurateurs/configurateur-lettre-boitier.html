<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Configurateur Lettres Boîtiers – Cofel</title>

<!-- Styles communs (si présents, mêmes que l’accueil) -->
<link rel="stylesheet" href="../styles/cofel.css" />
<link rel="stylesheet" href="../styles/cofel-config.css" />

<style>
  /* ===== Habillage Cofel (violet) — logique JS conservée ===== */
  :root{
    --violet:#5a2d82;
    --bg:#f6f3fa; --txt:#2b2140;
    --card:#fff; --bd:#e6daf4; --bd2:#d8cbe8;
  }
  *{box-sizing:border-box}
  body{font-family:Arial, Helvetica, sans-serif;background:var(--bg);margin:0;color:var(--txt)}
  h1{margin:0 0 14px;text-align:center}
  .wrap{max-width:980px;margin:20px auto;background:var(--card);border-radius:14px;box-shadow:0 10px 28px rgba(90,45,130,.12);padding:20px}
  label{display:block;margin-top:14px;font-weight:700}
  input,select{width:100%;padding:10px;margin-top:6px;border:1px solid var(--bd2);border-radius:10px;min-height:44px;background:#fff}
  input[type="number"]{appearance:textfield}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  @media (max-width:820px){ .grid{grid-template-columns:1fr} }
  .help{font-size:12px;color:#6f5b86;margin-top:6px}

  .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#fcfaff;color:#4a2a6c;font-size:12px;border:1px solid var(--bd);margin:6px 6px 0 0}
  .result{
    margin-top:22px;padding:16px;background:#fcfaff;border:1px solid #dec5f2;border-radius:12px;font-size:18px;text-align:center;
    box-shadow:0 8px 18px rgba(90,45,130,.08)
  }
  .muted{color:#7d6f8e;font-size:12px;margin-top:8px;white-space:pre-wrap}

  .diag{
    margin-top:12px;border:1px dashed #cdb6e6;border-radius:12px;padding:12px;background:#fff;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;font-size:12px;display:none;white-space:pre-wrap
  }
  .note{
    margin-top:10px;background:#fff7e6;border:1px solid #ffd38a;border-radius:10px;padding:10px;font-size:13px;color:#5a430e;display:none
  }

  /* Bandeau / footer (fallback si cofel.css absent) */
  .cofel-header{background:var(--violet);color:#fff}
  .cofel-header .row{max-width:1100px;margin:0 auto;display:flex;align-items:center;gap:16px;padding:10px 14px}
  .cofel-back{color:#fff;text-decoration:none;border:1px solid rgba(255,255,255,.35);padding:8px 12px;border-radius:10px}
  .cofel-brand{display:flex;align-items:center;gap:10px}
  .cofel-brand img{height:36px;border-radius:6px;object-fit:cover}
  .cofel-title{font-size:18px;margin:0}
  .cofel-container{max-width:1100px;margin:0 auto;padding:14px}
  .cofel-footer{
    margin:24px 0 0;padding:14px;text-align:center;color:#6f5b86;font-size:13px;
    border-top:1px solid var(--bd);background:#fbf9fe
  }
</style>
</head>
<body>

<!-- Bandeau violet / retour -->
<header class="cofel-header">
  <div class="row">
    <a class="cofel-back" href="../index.html">⬅ Retour aux configurateurs</a>
    <div class="cofel-brand">
      <img src="../assets/logo cofel.jpg" alt="Cofel" />
      <h1 class="cofel-title">Configurateur — Lettres Boîtiers</h1>
    </div>
  </div>
</header>

<div class="cofel-container">
  <h1>Lettres Boîtiers</h1>

  <div class="wrap">
    <div class="grid">
      <div>
        <label for="famille">Type de lettre boîtier</label>
        <select id="famille"><option value="">— sélectionnez —</option></select>
      </div>
      <div>
        <label for="quantite">Quantité</label>
        <input type="number" id="quantite" value="1" min="1"/>
      </div>
    </div>

    <div class="grid">
      <div>
        <label for="hauteur">Hauteur (mm)</label>
        <input type="number" id="hauteur" placeholder="Ex : 325" min="1"/>
        <div id="rangesHelp" class="help"></div>
      </div>
      <div>
        <label for="variant">Éclairage (si présent)</label>
        <select id="variant"><option value="">— (aucun filtre) —</option></select>
        <div class="help" id="variantHelp"></div>
        <div id="dibondRule" class="note">Pour les <b>faces Dibond</b> : si un éclairage est choisi, c’est du <b>rétroéclairage</b> et la <b>fixation est obligatoire</b> (à prévoir dans le devis).</div>
      </div>
    </div>

    <div class="result">
      <p>Prix HT : <span id="prixHT">0,00</span> €</p>
      <p>Prix TTC : <span id="prixTTC">0,00</span> €</p>
    </div>

    <label style="margin-top:14px;display:flex;align-items:center;gap:8px;font-weight:normal">
      <input type="checkbox" id="toggleDiag"/> Afficher le diagnostic (débogage)
    </label>
    <div id="diag" class="diag"></div>

    <div id="msg" class="muted"></div>
  </div>
</div>

<!-- Pied de page -->
<footer class="cofel-footer">
  © Cofel — ZA du Perquoi, 72560 Changé — SIRET 927 659 458 00024 — TVA FR80927659458
</footer>

<script>
/* =======================
   CONFIG
   ======================= */
const TVA = 0.20;
const FAMILLES = [
  {
    name: "Boîtier Bâton – face PMMA blanc diffusant",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/lettre%20boitier%20baton%20chants%20alu%20laqu%C3%A9%20et%20face%20PMMA%20blanc%20diffusant.csv"
  },
  {
    name: "Boîtier Bâton – face Dibond",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20laqu%C3%A9e%20B%C3%A2ton%20chants%20aluminium%20et%20face%20avant%20type%20Dibond.csv"
  },
  {
    name: "Boîtier Fantaisie – face Dibond",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20laqu%C3%A9e%20Fantaisie%20chants%20aluminium%20et%20face%20avant%20type%20Dibond.csv"
  },
  {
    name: "Boîtier Fantaisie – face PMMA blanc diffusant",
    url: "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20boitier%20Fantaisie%20chants%20laqu%C3%A9s%20et%20faces%20PMMA%20blanc%20diffusant.csv"
  }
];

/* =======================
   STATE & ELEMENTS
   ======================= */
let CURRENT = null; // {name,url}
let HEADS = [];
let ROWS = [];
let MAP = null;     // {hminKey,hmaxKey,baseKey,variantKey}

const elFam = document.getElementById('famille');
const elQ   = document.getElementById('quantite');
const elH   = document.getElementById('hauteur');
const elVar = document.getElementById('variant');
const elVarHelp = document.getElementById('variantHelp');
const elRanges = document.getElementById('rangesHelp');
const elHT  = document.getElementById('prixHT');
const elTTC = document.getElementById('prixTTC');
const elMsg = document.getElementById('msg');
const elDiag= document.getElementById('diag');
const elTgD = document.getElementById('toggleDiag');
const elDibondRule = document.getElementById('dibondRule');

/* =======================
   HELPERS
   ======================= */
function normKey(k){
  return String(k||'').toLowerCase()
   .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
   .replace(/[^a-z0-9]+/g,'').trim();
}
function numFR(v){
  if(v===null||v===undefined) return NaN;
  let s = String(v).trim().replace(/€/g,'').replace(/[\u00A0\u202F]/g,'');
  if(s.includes(',') && s.includes('.')) s = s.replace(/\./g,'');
  s = s.replace(',', '.');
  const m = s.match(/-?\d+(\.\d+)?/);
  return m ? parseFloat(m[0]) : NaN;
}
function euro(n){ return (isFinite(n)?n:0).toFixed(2).replace('.', ','); }

/* ===== CSV Parser robuste ===== */
function parseCSVLine(line, sep=','){
  const out=[]; let cur=''; let inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i], nx=line[i+1];
    if(ch==='"'){
      if(inQ && nx==='"'){ cur+='"'; i++; }
      else inQ=!inQ;
    }else if(ch===sep && !inQ){
      out.push(cur); cur='';
    }else{
      cur+=ch;
    }
  }
  out.push(cur);
  return out;
}
function normalizeWeirdCSV(text){
  let t = text.replace(/^\uFEFF/,'').replace(/\r/g,'');
  const manyQuotes = (t.match(/"/g)||[]).length > 50;
  const fewNewlines = (t.match(/\n/g)||[]).length < 3;
  if(manyQuotes && fewNewlines){
    t = t.replace(/""/g,'"');
    const blocks=[]; const re=/"([^"]*)"/g; let m;
    while((m=re.exec(t))!==null){ blocks.push(m[1]); }
    if(!blocks.length) return text;
    const cols = parseCSVLine(blocks[0], ',').length;
    const lines=[];
    for(let i=0;i<blocks.length;i+=cols){
      lines.push(blocks.slice(i,i+cols).map(s=>`"${s}"`).join(','));
    }
    return lines.join('\n');
  }
  return t.split('\n').map(l=>{
    const s=l.trim();
    if(s.startsWith('"') && s.endsWith('"')) return s.slice(1,-1);
    return s;
  }).join('\n');
}
function parseCSVAuto(text){
  const norm = normalizeWeirdCSV(text);
  const lines = norm.split('\n').filter(l=>l.trim()!=='');
  if(!lines.length) return {rawHeads:[],rows:[]};
  const first = lines[0];
  const sep = (first.match(/;/g)||[]).length > (first.match(/,/g)||[]).length ? ';' : ',';
  const rawHeads = parseCSVLine(lines[0], sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
  const rows = lines.slice(1).map(line=>{
    const cells = parseCSVLine(line, sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
    const o={}; rawHeads.forEach((h,i)=>o[h]=cells[i]??'' ); return o;
  });
  return {rawHeads, rows};
}

/* ===== Mapping automatique ===== */
function buildMapping(rawHeads){
  const NK = rawHeads.map(normKey);
  const findExact = (nkWanted)=> {
    const idx = NK.findIndex(k=>k===nkWanted);
    return idx>=0 ? rawHeads[idx] : null;
  };
  const findLoose = (...res)=> {
    for(let i=0;i<NK.length;i++){
      const k=NK[i];
      if(res.every(re=>re.test(k))) return rawHeads[i];
    }
    return null;
  };

  // D’après tes CSV : HauteurMin_mm, HauteurMax_mm, PrixUnitaire_EUR, Eclairage (quand présent)
  const hminKey   = findExact('hauteurminmm') || findLoose(/hauteur/,/min/);
  const hmaxKey   = findExact('hauteurmaxmm') || findLoose(/hauteur/,/max/);
  const baseKey   = findExact('prixunitaireeur') || findLoose(/prix|tarif/,/eur|ht|unitaire/);
  const variantKey= findExact('eclairage') || findLoose(/eclairage|eclair|led/);

  return { hminKey, hmaxKey, baseKey, variantKey };
}

/* ===== UI helpers ===== */
function fillFamilles(){
  elFam.innerHTML = '<option value="">— sélectionnez —</option>' +
    FAMILLES.map((f,i)=>`<option value="${i}">${f.name}</option>`).join('');
}
function buildVariantUI(){
  elVar.innerHTML = '<option value="">— (aucun filtre) —</option>';
  elVarHelp.textContent = '';
  if(!MAP?.variantKey) return;
  const key = MAP.variantKey;
  const values = [...new Set(ROWS.map(r=>String(r[key]||'').trim()).filter(Boolean))].sort();
  if(!values.length) return;
  elVar.innerHTML = '<option value="">— sélectionnez —</option>' +
    values.map(v=>`<option value="${v}">${v}</option>`).join('');
  elVarHelp.textContent = `Filtre sur « ${key} ».`;
}
function buildRangesHelp(){
  if(!MAP?.hmaxKey){ elRanges.textContent=''; return; }
  const kmin = MAP.hminKey, kmax = MAP.hmaxKey;
  const pills=[]; const seen=new Set();
  for(const r of ROWS){
    const a = numFR(kmin? r[kmin] : 0);
    const b = numFR(r[kmax]);
    if(!Number.isFinite(b)) continue;
    const txt = (Number.isFinite(a) && a>0) ? `${a}–${b}` : `≤ ${b}`;
    if(!seen.has(txt)){ pills.push(txt); seen.add(txt); }
  }
  pills.sort((A,B)=> Number(A.replace(/[^\d]/g,'')) - Number(B.replace(/[^\d]/g,'')));
  elRanges.innerHTML = pills.map(p=>`<span class="pill">${p}</span>`).join('');
}

/* ===== Règle info “Dibond + éclairage” ===== */
function updateDibondRule(){
  const isDibondFamily = (CURRENT?.name||'').toLowerCase().includes('dibond');
  const hasLighting = !!elVar.value;
  elDibondRule.style.display = (isDibondFamily && hasLighting) ? 'block' : 'none';
}

/* ===== Cœur du calcul ===== */
function filterRowsByVariant(rows){
  if(!MAP?.variantKey) return rows;
  const v = elVar.value;
  if(!v) return rows;
  return rows.filter(r => String(r[MAP.variantKey]||'').trim() === v);
}
function findRowForHeight(H){
  const kmin = MAP.hminKey, kmax = MAP.hmaxKey;
  let rows = filterRowsByVariant(ROWS);
  if(!rows.length) return null;

  rows = rows.slice().sort((a,b)=>{
    const amin = numFR(kmin ? a[kmin] : 0), amax = numFR(a[kmax]);
    const bmin = numFR(kmin ? b[kmin] : 0), bmax = numFR(b[kmax]);
    if(amin!==bmin) return amin-bmin;
    return amax-bmax;
  });

  const first = rows[0];
  const firstMax = numFR(first[kmax]);
  if(Number.isFinite(firstMax) && H <= firstMax) return first;

  for(const r of rows){
    const a = numFR(kmin ? r[kmin] : 0);
    const b = numFR(r[kmax]);
    if(Number.isFinite(a) && Number.isFinite(b) && H>=a && H<=b) return r;
  }
  return rows[rows.length-1] || null;
}
function compute(){
  const H = Number(elH.value||0);
  const Q = Math.max(1, Number(elQ.value||1));
  if(!(H>0) || !ROWS.length || !MAP?.hmaxKey || !MAP?.baseKey){
    elHT.textContent='0,00'; elTTC.textContent='0,00';
    renderDiag(null,H,Q); updateDibondRule(); return;
  }
  const row = findRowForHeight(H);
  const base = row ? numFR(row[MAP.baseKey]) : 0;
  const totalHT = (base || 0) * Q;
  const totalTTC = totalHT * (1+TVA);
  elHT.textContent = euro(totalHT);
  elTTC.textContent = euro(totalTTC);
  renderDiag(row,H,Q,base,totalHT,totalTTC);
  updateDibondRule();
}
function renderDiag(row,H,Q,base=0,tHT=0,tTTC=0){
  if(!elTgD.checked){ elDiag.style.display='none'; return; }
  elDiag.style.display='block';
  if(!row){
    elDiag.textContent = `DIAG: H=${H} | lignes=${ROWS.length}\n→ Saisir une hauteur et choisir une famille.`;
    return;
  }
  const seg = [
    `Famille: ${CURRENT?.name||''}`,
    MAP?.variantKey ? `Filtre ${MAP.variantKey}: ${elVar.value||'(aucun)'}` : null,
    `Hauteur saisie: ${H} → tranche: [${MAP.hminKey? row[MAP.hminKey] : '0'} … ${row[MAP.hmaxKey]}]`,
    `Prix unitaire: ${euro(base)} € | Qté: ${Q}`,
    `TOTAL HT: ${euro(tHT)} € | TTC: ${euro(tTTC)} €`
  ].filter(Boolean);
  elDiag.textContent = seg.join('\n');
}

/* ===== LOADERS ===== */
async function fetchText(u){
  const r = await fetch(u, {cache:'no-store'});
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.text();
}
async function loadFamily(f){
  const txt = await fetchText(f.url);
  const parsed = parseCSVAuto(txt);
  HEADS = parsed.rawHeads;
  ROWS  = parsed.rows;
  MAP   = buildMapping(HEADS);

  buildVariantUI();
  buildRangesHelp();

  elMsg.textContent = `Fichier chargé: ${f.name}
En-têtes: ${HEADS.join(' | ')}
Colonnes → HauteurMin: ${MAP.hminKey||'n/a'} | HauteurMax: ${MAP.hmaxKey||'n/a'} | Prix: ${MAP.baseKey||'n/a'} | Variante: ${MAP.variantKey||'n/a'}`;
}

/* ===== INIT & BIND ===== */
function bind(){
  elFam.addEventListener('change', async ()=>{
    const i = parseInt(elFam.value,10);
    if(isNaN(i)){ CURRENT=null; ROWS=[]; MAP=null; compute(); return; }
    CURRENT = FAMILLES[i];
    elMsg.textContent = 'Chargement…';
    try{
      await loadFamily(CURRENT);
      elMsg.textContent += '\nPrêt.';
      compute();
    }catch(e){
      console.error(e);
      elMsg.textContent = 'Erreur de chargement: '+e.message;
    }
  });
  elQ.addEventListener('input', compute);
  elH.addEventListener('input', compute);
  elVar.addEventListener('change', compute);
  elTgD.addEventListener('change', compute);
}
(function init(){ fillFamilles(); bind(); })();
</script>
</body>
</html>
