<!DOCTYPE html>
<html lang="fr">
  <head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../styles/cofel.css">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <div style="background:#003366; padding:10px;">
  <a href="../index.html" style="
    color:white;
    text-decoration:none;
    font-weight:bold;
    font-family:Arial, sans-serif;
    background:#0055aa;
    padding:8px 14px;
    border-radius:6px;
    display:inline-block;
  ">
    ⬅ Retour aux configurateurs
  </a>
</div>

<title>Configurateur Enseignes Drapeaux – Cofel (Version simplifiée)</title>
<style>
  body{font-family:Arial, sans-serif;background:#f4f4f4;margin:0;padding:24px;color:#333}
  h1{text-align:center;margin:0 0 16px}
  .wrap{max-width:820px;margin:0 auto;background:#fff;border-radius:12px;box-shadow:0 10px 28px rgba(0,0,0,.08);padding:20px}
  label{display:block;margin-top:14px;font-weight:700}
  input,select{width:100%;padding:10px;margin-top:6px;border:1px solid #ccc;border-radius:8px;min-height:44px;font:inherit}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:800px){.grid{grid-template-columns:1fr}}
  fieldset{border:1px solid #ddd;border-radius:10px;padding:10px;margin-top:8px}
  fieldset legend{padding:0 8px;font-weight:700}
  .option-item{display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid #e1e1e1;border-radius:8px;background:#fafafa;min-height:40px;cursor:pointer}
  .option-item input{transform:scale(1.1)}
  .result{margin-top:18px;padding:14px;background:#e9f5ff;border:1px solid #b3e0ff;border-radius:10px;text-align:center;font-size:18px}
  .muted{color:#666;font-size:12px;margin-top:8px;white-space:pre-wrap}
</style>
</head>
<body>
<h1>Configurateur Enseignes Drapeaux</h1>
<div class="wrap">
  <div class="grid">
    <div>
      <label for="forme">Forme</label>
      <select id="forme"><option value="">(choisir)</option></select>
    </div>
    <div>
      <label for="quantite">Quantité</label>
      <input type="number" id="quantite" min="1" value="1" />
    </div>
  </div>

  <div class="grid">
    <div>
      <fieldset>
        <legend>Options</legend>
        <label class="option-item">
          <input type="checkbox" id="optLaquage" />
          <span>Laquage (sur drapeau carré – base prélaqué)</span>
        </label>
        <label class="option-item">
          <input type="checkbox" id="optAjourLumi" />
          <span>Ajourage + lumineux + laquage</span>
        </label>
      </fieldset>
      <div class="muted" id="noteForme"></div>
    </div>
    <div>
      <label for="dimension">Dimension</label>
      <select id="dimension"><option value="">(choisir la dimension)</option></select>
      <div id="helpDim" class="muted"></div>
    </div>
  </div>

  <div class="result">
    <p>Prix HT : <span id="prixHT">0,00</span> €</p>
    <p>Prix TTC : <span id="prixTTC">0,00</span> €</p>
  </div>

  <div id="msg" class="muted"></div>
</div>

<script>
/* ===== PARAMS ===== */
const TVA = 0.20;
const CSV_URL = "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/Enseigne%20drapeaux.csv";

/* ===== STATE / DOM ===== */
let HEADS=[], ROWS=[], MAP=null;
const $ = id=>document.getElementById(id);
const elForme=$("forme"), elQ=$("quantite"), elDim=$("dimension");
const elLaq=$("optLaquage"), elAJL=$("optAjourLumi");
const elHT=$("prixHT"), elTTC=$("prixTTC");
const elMsg=$("msg"), elHelpDim=$("helpDim"), elNote=$("noteForme");

/* ===== Utils ===== */
function normKey(k){
  return String(k||'').toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-z0-9+]+/g,'').trim();
}
function numFR(v){
  if(v===null||v===undefined) return NaN;
  let s=String(v).trim().replace(/€/g,'').replace(/[\u00A0\u202F]/g,'').replace(/\s+/g,'');
  if(s.includes(',') && s.includes('.')) s=s.replace(/\./g,'');
  s=s.replace(',', '.');
  const m=s.match(/-?\d+(\.\d+)?/);
  return m?parseFloat(m[0]):NaN;
}
function euro(n){ return (isFinite(n)?n:0).toFixed(2).replace('.', ','); }

/* Robust CSV parser: accepte \r\n, \n ou \r */
function parseCSVAuto(text){
  const raw = String(text || "").replace(/^\uFEFF/, "");
  const lines = raw.split(/\r\n|\n|\r/).filter(l => l.trim() !== "");
  if (!lines.length) return { rawHeads: [], rows: [] };

  const first = lines[0];
  const sep = ((first.match(/;/g) || []).length > (first.match(/,/g) || []).length) ? ';' : ',';

  function parseCSVLine(line){
    const out=[]; let cur=''; let inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i], nx=line[i+1];
      if(ch === '"'){
        if(inQ && nx === '"'){ cur+='"'; i++; } else { inQ = !inQ; }
      } else if(ch === sep && !inQ){
        out.push(cur); cur='';
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  const rawHeads = parseCSVLine(first).map(s => s.replace(/^"+|"+$/g,'').trim());
  const rows = lines.slice(1).map(line => {
    const cells = parseCSVLine(line).map(s => s.replace(/^"+|"+$/g,'').trim());
    const o = {}; rawHeads.forEach((h,i)=> o[h] = cells[i] ?? '');
    return o;
  });

  return { rawHeads, rows };
}

function buildMapping(rawHeads){
  const nk=rawHeads.map(normKey);
  const find=(key)=>{ const i=nk.findIndex(k=>k===key); return i>=0?rawHeads[i]:null; };
  const like=(...res)=>{ for(let i=0;i<nk.length;i++){ const k=nk[i]; if(res.every(re=>re.test(k))) return rawHeads[i]; } return null; };

  const TITRE   = find('titre')||like(/titre/);
  const FORME   = find('forme')||like(/forme/);
  const DIM     = find('dimensionmm')||like(/dimension.*mm|dim/);
  const FIN     = find('finition')||like(/fini/);
  const PRIX    = find('prixeurl')||like(/prix.*eur|prix/);
  const COM     = find('commentaire')||like(/comment/);
  const OPTAJL  = find('opt_ajourage+lumineux')||like(/ajourage\+?lumineux|ajour|lumineux/);

  return {TITRE,FORME,DIM,FIN,PRIX,COM,OPTAJL};
}

/* ===== Data helpers ===== */
function distinct(values){ return [...new Set(values)]; }

function populateFormes(){
  const formes = distinct(ROWS.map(r=>String(r[MAP.FORME]||'').toLowerCase()).filter(Boolean))
                  .sort((a,b)=>a.localeCompare(b,'fr',{sensitivity:'base'}));
  const cur=elForme.value; elForme.innerHTML='';
  const o0=document.createElement('option'); o0.value=''; o0.textContent='(choisir)'; elForme.appendChild(o0);
  formes.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; elForme.appendChild(o); });
  if(formes.includes(cur)) elForme.value=cur;
}

function filteredPool(){
  let pool=[...ROWS];
  if(elForme.value) pool=pool.filter(r=>String(r[MAP.FORME]).toLowerCase()===elForme.value);

  const fin = (r)=>String(r[MAP.FIN]).trim().toLowerCase();
  const opt = (r)=>String(r[MAP.OPTAJL]).trim().toLowerCase();

  if(elForme.value==='carré'){
    if(elAJL.checked){
      // AJL = Vrai + laqué obligatoire
      pool = pool.filter(r=> opt(r)==='vrai' && fin(r)==='laqué' );
    }else{
      // Laquage optionnel (base prélaqué)
      if(elLaq.checked){
        pool = pool.filter(r=> fin(r)==='laqué' && opt(r)!=='vrai' );
      }else{
        pool = pool.filter(r=> fin(r)==='prélaqué' && opt(r)!=='vrai' );
      }
    }
  }else if(elForme.value==='rond'){
    // Laquage OBLIGATOIRE
    pool = pool.filter(r=> fin(r)==='laqué' );
    // AJL selon case
    if(elAJL.checked){ pool = pool.filter(r=> opt(r)==='vrai'); }
    else             { pool = pool.filter(r=> opt(r)!=='vrai'); }
  }else if(elForme.value){
    // Toute autre forme éventuelle: considérons laqué par défaut
    pool = pool.filter(r=> fin(r)==='laqué' );
    if(elAJL.checked && MAP.OPTAJL) pool = pool.filter(r=> opt(r)==='vrai');
    else if(MAP.OPTAJL)             pool = pool.filter(r=> opt(r)!=='vrai');
  }
  return pool;
}

function populateDimensions(){
  const pool=filteredPool();
  const dims = distinct(pool.map(r=>String(r[MAP.DIM]||'').trim()).filter(Boolean))
                .sort((a,b)=>a.localeCompare(b,'fr',{numeric:true}));
  const cur=elDim.value; elDim.innerHTML='';
  const o0=document.createElement('option'); o0.value=''; o0.textContent='(choisir la dimension)'; elDim.appendChild(o0);
  dims.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; elDim.appendChild(o); });
  if(dims.includes(cur)) elDim.value=cur;
  elHelpDim.textContent = dims.length?`Dimensions dispo: ${dims.slice(0,10).join(' • ')}${dims.length>10?' …':''}`:'';
}

function findRow(){
  const pool=filteredPool();
  if(!pool.length) return null;
  if(elDim.value){
    const exact=pool.find(r=>String(r[MAP.DIM]).trim()===elDim.value);
    if(exact) return exact;
  }
  return pool[0];
}

/* ===== Compute ===== */
function compute(){
  const isCarre = (elForme.value==='carré');
  const isRond  = (elForme.value==='rond');

  // État des options
  if(isCarre){
    // sur carré: base prélaqué; AJL désactive la case laquage (puisqu'il impose laqué)
    elLaq.disabled = elAJL.checked ? true : false;
    if(!elAJL.checked && !elLaq.disabled) {
      // l'utilisateur choisit librement laquage
    }
    elNote.textContent = elAJL.checked
      ? "Carré : AJL = laquage imposé."
      : "Carré : base prélaqué, coche 'Laquage' pour passer en laqué.";
  }else if(isRond){
    // rond: laquage obligatoire → coche la case et désactive
    elLaq.checked  = true;
    elLaq.disabled = true;
    elNote.textContent = "Rond : laquage obligatoire. Coche 'Ajourage + lumineux + laquage' pour la version lumineuse.";
  }else{
    elLaq.disabled = true;
    elLaq.checked  = false;
    elNote.textContent = "Forme : sélectionne une forme pour voir les dimensions.";
  }

  const Q = Math.max(1, Number(elQ.value||1));
  const row = findRow();

  if(!row){
    elHT.textContent='0,00';
    elTTC.textContent='0,00';
    return;
  }

  let unit = numFR(row[MAP.PRIX]);
  if(!isFinite(unit)) unit=0;

  const totalHT = unit * Q;
  const totalTTC = totalHT * (1+TVA);

  elHT.textContent  = euro(totalHT);
  elTTC.textContent = euro(totalTTC);
}

/* ===== Load CSV (robuste) ===== */
async function loadCSV(){
  try{
    const r = await fetch(CSV_URL, { cache: 'no-store' });
    if(!r.ok) throw new Error('HTTP '+r.status);
    const txt = await r.text();

    const { rawHeads, rows } = parseCSVAuto(txt);
    HEADS = rawHeads; ROWS = rows; MAP = buildMapping(HEADS);

    populateFormes();
    populateDimensions();
    compute();

    const preview = String(txt).slice(0, 120).replace(/\s+/g,' ');
    elMsg.textContent = `CSV chargé: ${rows.length} lignes | en-têtes: ${HEADS.join(' | ')} | aperçu brut: "${preview}${txt.length>120?'…':''}"`;
  }catch(e){
    elMsg.textContent = 'Erreur chargement CSV: ' + (e && e.message ? e.message : e);
  }
}

/* ===== INIT & Events ===== */
["input","change"].forEach(evt=>{
  [forme, quantite, optLaquage, optAjourLumi, dimension].forEach(el=>{
    el.addEventListener(evt, (e)=>{
      if(e.target===forme || e.target===optLaquage || e.target===optAjourLumi){
        populateDimensions();
      }
      compute();
    });
  });
});

loadCSV();
</script>
</body>
</html>



