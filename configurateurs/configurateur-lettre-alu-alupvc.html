<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <div style="background:#003366; padding:10px;">
  <a href="../index.html" style="
    color:white;
    text-decoration:none;
    font-weight:bold;
    font-family:Arial, sans-serif;
    background:#0055aa;
    padding:8px 14px;
    border-radius:6px;
    display:inline-block;
  ">
    ⬅ Retour aux configurateurs
  </a>
</div>

<title>Configurateur Lettres Aluminium 20/10 & Dibond 3 mm - Cofel</title>
<style>
  body{font-family:Arial, sans-serif;background:#f4f4f4;margin:0;padding:24px;color:#333}
  h1{text-align:center;margin:0 0 16px}
  .wrap{max-width:860px;margin:0 auto;background:#fff;border-radius:12px;box-shadow:0 10px 28px rgba(0,0,0,.08);padding:20px}
  label{display:block;margin-top:14px;font-weight:700}
  input,select{width:100%;padding:10px;margin-top:6px;border:1px solid #ccc;border-radius:8px;min-height:44px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:800px){.grid{grid-template-columns:1fr}}
  fieldset{border:1px solid #ddd;border-radius:10px;padding:10px;margin-top:8px}
  fieldset legend{padding:0 8px;font-weight:700}
  .option-item{display:flex;align-items:center;gap:8px;padding:8px 10px;border:1px solid #e1e1e1;border-radius:8px;background:#fafafa;min-height:40px;cursor:pointer}
  .option-item input{transform:scale(1.1)}
  .result{margin-top:18px;padding:14px;background:#e9f5ff;border:1px solid #b3e0ff;border-radius:10px;text-align:center;font-size:18px}
  .muted{color:#666;font-size:12px;margin-top:8px;white-space:pre-wrap}
  .diag{margin-top:12px;border:1px dashed #ccc;border-radius:10px;padding:10px;background:#fafafa;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;font-size:12px;display:none;white-space:pre-wrap}
</style>
</head>
<body>
<h1>Configurateur Lettres Aluminium 20/10 & Dibond 3 mm</h1>

<div class="wrap">
  <div class="grid">
    <div>
      <label for="categorie">Catégorie</label>
      <select id="categorie">
        <option value="alu20">Lettre aluminium 20/10ème</option>
        <option value="dibond3">Lettre alu/pvc 3 mm (type Dibond)</option>
      </select>
    </div>
    <div>
      <label for="quantite">Quantité</label>
      <input type="number" id="quantite" min="1" value="1" />
    </div>
  </div>

  <div class="grid">
    <div>
      <label for="hauteur">Hauteur (mm)</label>
      <input type="number" id="hauteur" placeholder="Ex : 275" min="1" />
      <div id="helpRanges" class="muted"></div>
    </div>
    <div>
      <fieldset>
        <legend>Finition</legend>
        <label class="option-item">
          <input type="radio" name="finition" id="finitionBrut" value="brut" checked />
          <span>Brut (PrixBrut_EUR)</span>
        </label>
        <label class="option-item">
          <input type="radio" name="finition" id="finitionLaque" value="laque" />
          <span>Laqué (PrixLaque_EUR)</span>
        </label>
      </fieldset>

      <fieldset>
        <legend>Supplément</legend>
        <label class="option-item">
          <input type="checkbox" id="optFixation" />
          <span>Fixations (+ SupFixation_EUR)</span>
        </label>
      </fieldset>
    </div>
  </div>

  <div class="result">
    <p>Prix HT : <span id="prixHT">0,00</span> €</p>
    <p>Prix TTC : <span id="prixTTC">0,00</span> €</p>
  </div>

  <label style="margin-top:12px;display:flex;align-items:center;gap:8px;font-weight:normal">
    <input type="checkbox" id="toggleDiag" /> Afficher le diagnostic
  </label>
  <div id="diag" class="diag"></div>

  <div id="msg" class="muted"></div>
</div>

<script>
/* ===== CONFIG ===== */
const TVA = 0.20;
const CSV_URL = "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/lettres/Lettre%20alu%2020_10%20%C3%A8me%20ou%20Type%20Dibond%203%20mm.csv";

/* ===== STATE / DOM ===== */
let HEADS=[], ROWS=[], MAP=null;
const elH = document.getElementById("hauteur");
const elQ = document.getElementById("quantite");
const elFix = document.getElementById("optFixation");
const elFBrut = document.getElementById("finitionBrut");
const elFLaque = document.getElementById("finitionLaque");
const elPrixHT = document.getElementById("prixHT");
const elPrixTTC = document.getElementById("prixTTC");
const elDiag = document.getElementById("diag");
const elTgD = document.getElementById("toggleDiag");
const elMsg = document.getElementById("msg");
const elHelp = document.getElementById("helpRanges");

/* ===== Utils (robustes) ===== */
// normalise les clés d'en-tête
function normKey(k){
  return String(k||'').toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-z0-9]+/g,'').trim();
}
// convertit "12,00 €", "1 000", "1 000", "12.00" → nombre JS
function numFR(v){
  if(v===null||v===undefined) return NaN;
  let s = String(v).trim()
    .replace(/€/g,'')
    .replace(/[\u00A0\u202F]/g,'') // espaces insécables/fines
    .replace(/\s+/g,'');           // espaces normaux
  if(s.includes(',') && s.includes('.')) s = s.replace(/\./g,''); // retire . milliers si mixte
  s = s.replace(',', '.');
  const m = s.match(/-?\d+(\.\d+)?/);
  return m ? parseFloat(m[0]) : NaN;
}
function euro(n){ return (isFinite(n)?n:0).toFixed(2).replace('.', ','); }

/* ===== CSV parser béton (gère guillemets doublés) ===== */
function parseCSVLine(line, sep=','){
  const out=[]; let cur=''; let inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i], nx=line[i+1];
    if(ch==='"'){
      if(inQ && nx==='"'){ cur+='"'; i++; } else inQ=!inQ;
    }else if(ch===sep && !inQ){
      out.push(cur); cur='';
    }else{
      cur+=ch;
    }
  }
  out.push(cur);
  return out;
}
// Certains fichiers exportés arrivent “tout entre guillemets” avec "" internes.
// Cette fonction reconstruit un CSV propre ligne/colonne.
function normalizeWeirdCSV(t){
  t=t.replace(/^\uFEFF/,'').replace(/\r/g,'');
  const manyQuotes=(t.match(/"/g)||[]).length>50;
  const fewNL=(t.match(/\n/g)||[]).length<3;
  if(manyQuotes && fewNL){
    // cas: "Titre,""Hauteur_mm"",..." sur une seule (ou très longues) lignes
    t=t.replace(/""/g,'"'); // dédoublement
    const blocks=[]; const re=/"([^"]*)"/g; let m;
    while((m=re.exec(t))!==null) blocks.push(m[1]);
    if(!blocks.length) return t;
    const cols=parseCSVLine(blocks[0], ',').length;
    const lines=[];
    for(let i=0;i<blocks.length;i+=cols){
      lines.push(blocks.slice(i,i+cols).map(s=>`"${s}"`).join(','));
    }
    return lines.join('\n');
  }
  // enlève guillemets d'enrobage ligne à ligne
  return t.split('\n').map(l=>{
    const s=l.trim();
    if(s.startsWith('"') && s.endsWith('"')) return s.slice(1,-1);
    return s;
  }).join('\n');
}
function parseCSVAuto(text){
  const norm=normalizeWeirdCSV(text);
  const lines=norm.split('\n').filter(l=>l.trim()!=='');
  if(!lines.length) return {rawHeads:[], rows:[]};
  const first=lines[0];
  const sep=((first.match(/;/g)||[]).length>(first.match(/,/g)||[]).length)?';':',';
  const rawHeads=parseCSVLine(lines[0], sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
  const rows=lines.slice(1).map(line=>{
    const cells=parseCSVLine(line, sep).map(s=>s.replace(/^"+|"+$/g,'').trim());
    const o={}; rawHeads.forEach((h,i)=>o[h]=cells[i]??''); return o;
  });
  return {rawHeads, rows};
}

/* ===== Mapping auto selon tes en-têtes ===== */
function buildMapping(rawHeads){
  const nk=rawHeads.map(normKey);
  const find=(key)=>{ const i=nk.findIndex(k=>k===key); return i>=0?rawHeads[i]:null; };
  const findLoose=(...res)=>{ for(let i=0;i<nk.length;i++){ const k=nk[i]; if(res.every(re=>re.test(k))) return rawHeads[i]; } return null; };

  const hKey   = find('hauteurmm')      || findLoose(/hauteur/,/mm/);
  const brutKey= find('prixbruteur')    || findLoose(/prix.*brut|brut/i);
  const laqKey = find('prixlaqueeur')   || findLoose(/prix.*laque|laque/i);
  const fixKey = find('supfixationeur') || findLoose(/fixation/i);

  return {hKey, brutKey, laqKey, fixKey};
}

/* ===== Data helpers ===== */
function pickRowForHeight(H){
  const k=MAP.hKey;
  const pool = ROWS
    .map(r=>({row:r, h:numFR(r[k])}))
    .filter(x=>isFinite(x.h))
    .sort((a,b)=>a.h-b.h);
  if(!pool.length) return null;
  let chosen=pool[0];
  for(const x of pool){
    if(H <= x.h){ chosen=x; break; }
    chosen=x;
  }
  return chosen.row;
}

/* ===== UI ===== */
function showRanges(){
  const k=MAP?.hKey; if(!k){ helpRanges.textContent=''; return; }
  const vals=[...new Set(ROWS.map(r=>numFR(r[k])).filter(v=>isFinite(v)))].sort((a,b)=>a-b);
  helpRanges.textContent = vals.length ? `Hauteurs disponibles (exemples) : ${vals.slice(0,12).join(' • ')}${vals.length>12?' …':''}` : '';
}

/* ===== Calcul ===== */
function compute(){
  const H = Number(elH.value||0);
  const Q = Math.max(1, Number(elQ.value||1));
  if(!(H>0) || !ROWS.length || !MAP?.hKey){ elPrixHT.textContent='0,00'; elPrixTTC.textContent='0,00'; renderDiag(null,H,Q); return; }

  const row = pickRowForHeight(H);
  if(!row){ elPrixHT.textContent='0,00'; elPrixTTC.textContent='0,00'; renderDiag(null,H,Q); return; }

  // prix de base selon finition
  const brut = MAP.brutKey ? numFR(row[MAP.brutKey]) : NaN;
  const laqe = MAP.laqKey  ? numFR(row[MAP.laqKey])  : NaN;
  let unit = 0;
  if(elFLaque.checked && isFinite(laqe)) unit = laqe;
  else if(isFinite(brut)) unit = brut;
  else if(isFinite(laqe)) { unit=laqe; elFLaque.checked=true; elFBrut.checked=false; }

  // + fixation si cochée
  if(elFix.checked && MAP.fixKey){
    const fx=numFR(row[MAP.fixKey]);
    if(isFinite(fx)) unit += fx;
  }

  const totalHT = unit * Q;
  const totalTTC = totalHT * (1+TVA);
  elPrixHT.textContent  = euro(totalHT);
  elPrixTTC.textContent = euro(totalTTC);

  renderDiag(row,H,Q,brut,laqe,unit,totalHT,totalTTC);
}

function renderDiag(row,H,Q,brutVal=NaN, laqVal=NaN, unit=0, tHT=0, tTTC=0){
  if(!elTgD.checked){ elDiag.style.display='none'; return; }
  elDiag.style.display='block';
  if(!row){ elDiag.textContent=`DIAG: H=${H} | lignes=${ROWS.length} | mapping=${JSON.stringify(MAP)}`; return; }
  const k=MAP.hKey;
  const fxTxt = (MAP.fixKey && elFix.checked) ? euro(numFR(row[MAP.fixKey])||0)+' €' : '0,00 €';
  elDiag.textContent = [
    `Hauteur saisie: ${H} → Hauteur retenue: ${row[k]}`,
    `Brut lu: ${isFinite(brutVal)?euro(brutVal):'—'} € | Laqué lu: ${isFinite(laqVal)?euro(laqVal):'—'} €`,
    `Fixation ajoutée: ${fxTxt}`,
    `Finition choisie: ${elFLaque.checked?'Laqué':'Brut'}`,
    `Unitaire: ${euro(unit)} €`,
    `Qté: ${Q} → TOTAL HT: ${euro(tHT)} € | TTC: ${euro(tTTC)} €`
  ].join('\n');
}

/* ===== LOAD ===== */
async function fetchText(u){
  const r = await fetch(u, {cache:'no-store'});
  if(!r.ok) throw new Error('HTTP '+r.status);
  return await r.text();
}
async function loadCSV(){
  const txt = await fetchText(CSV_URL);
  const {rawHeads, rows} = parseCSVAuto(txt);
  HEADS = rawHeads;
  ROWS  = rows;
  MAP   = buildMapping(HEADS);

  msg.textContent =
    `CSV chargé.\nEn-têtes: ${HEADS.join(' | ')}\nColonnes → Hauteur: ${MAP.hKey||'n/a'} | Brut: ${MAP.brutKey||'n/a'} | Laqué: ${MAP.laqKey||'n/a'} | Fixation: ${MAP.fixKey||'n/a'}`;

  showRanges();
  compute();
}

/* ===== INIT ===== */
["input","change"].forEach(evt=>{
  [hauteur, quantite, optFixation, finitionBrut, finitionLaque, toggleDiag].forEach(el=>{
    el.addEventListener(evt, compute);
  });
});
loadCSV().catch(e=>{ msg.textContent='Erreur: '+e.message; });
</script>
</body>
</html>

