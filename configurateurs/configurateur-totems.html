<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Configurateur Totems – Cofel</title>

<link rel="stylesheet" href="../styles/cofel.css" />
<link rel="stylesheet" href="../styles/cofel-config.css" />

<style>
  .radio-row{display:flex;gap:8px;flex-wrap:wrap}
  .radio-row label,.opt-row{
    font-weight:600;border:1px solid #ddd;border-radius:10px;
    padding:6px 10px;display:flex;align-items:center;gap:8px;background:#fff;
  }
  .opt-row input[type="checkbox"]{transform:scale(1.1)}
  .wrap{max-width:860px;margin:0 auto;background:#fff;border-radius:12px;box-shadow:0 10px 28px rgba(0,0,0,.08);padding:20px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .result{
    background:#fcfaff;border:1px solid #dec5f2;border-radius:12px;
    padding:16px;margin:16px 0;text-align:center;font-size:18px;
    box-shadow:0 8px 18px rgba(90,45,130,.08);
  }
  .muted{color:#7d6f8e;font-size:12px;white-space:pre-wrap}
  label{display:block;margin-top:10px;font-weight:700}
  select,input{width:100%;padding:10px;margin-top:6px;border:1px solid #ddd;border-radius:10px}
</style>
</head>
<body>

<header class="cofel-header">
  <div class="row">
    <a class="cofel-back" href="../index.html">⬅ Retour aux configurateurs</a>
    <div class="cofel-brand">
      <img src="../assets/logo cofel.jpg" alt="Cofel" />
      <h1 class="cofel-title">Configurateur — Totems</h1>
    </div>
  </div>
</header>

<div class="cofel-container">
  <h1 style="margin:8px 0 14px">Totems</h1>

  <div class="wrap">
    <label for="type">Type de face</label>
    <select id="type"><option value="">— sélectionnez —</option></select>

    <div class="grid">
      <div>
        <label for="hauteur">Hauteur (mm)</label>
        <select id="hauteur"><option value="">— sélectionnez —</option></select>
      </div>
      <div>
        <label for="largeur">Largeur (mm)</label>
        <select id="largeur"><option value="">— sélectionnez —</option></select>
      </div>
    </div>

    <label>Options (multi-choix)</label>
    <div id="optionsBox" class="options-wrap">
      <div class="opt-row"><em>Aucune option disponible tant que la hauteur n’est pas choisie.</em></div>
    </div>

    <label for="quantite">Quantité</label>
    <input type="number" id="quantite" value="1" min="1"/>

    <div class="result">
      <p>Prix HT : <span id="prixHT">0,00</span> €</p>
      <p>Prix TTC : <span id="prixTTC">0,00</span> €</p>
    </div>

    <div id="msg" class="muted"></div>
  </div>
</div>

<footer class="cofel-footer">
  © Cofel — ZA du Perquoi, 72560 Changé — SIRET 927 659 458 00024 — TVA FR80927659458
</footer>

<script>
/* ------- CONFIG ------- */
const TVA = 0.20;

/* Candidats de chemins pour les CSV (relatifs + Raw GitHub) */
const CANDIDATES_TARIFS = [
  "../styles/Tarifs_Totems_.csv",
  "../styles/Tarifs_Totems.csv",
  "../Tarifs_Totems_.csv",
  "../Tarifs_Totems.csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/styles/Tarifs_Totems_.csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/Tarifs_Totems_.csv"
];
const CANDIDATES_OPTIONS = [
  "../styles/option platine et panier de crosses.csv",
  "../styles/option platine et panier de crosses (1).csv",
  "../option platine et panier de crosses.csv",
  "../option platine et panier de crosses (1).csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/styles/option%20platine%20et%20panier%20de%20crosses.csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/styles/option%20platine%20et%20panier%20de%20crosses%20(1).csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/option%20platine%20et%20panier%20de%20crosses.csv",
  "https://raw.githubusercontent.com/stevens-cofel/configurateur-cofel/refs/heads/main/option%20platine%20et%20panier%20de%20crosses%20(1).csv"
];

/* ------- STATE ------- */
let RAW_TARIFFS = [], RAW_OPTIONS = [];
let RAW_HEADERS_T = [], RAW_HEADERS_O = [];
let HEADS_T = [], HEADS_O = [];
let TARIFFS = [], OPTIONS = [];

/* auto-map */
let MAP_T = {type:null,h:null,l:null,price:null};
let MAP_O = {type:null,hmin:null,hmax:null,price:null,actif:null};

/* ------- ELEMENTS ------- */
const elType = document.getElementById('type');
const elH    = document.getElementById('hauteur');
const elL    = document.getElementById('largeur');
const elOptsBox = document.getElementById('optionsBox');
const elQte  = document.getElementById('quantite');
const elHT   = document.getElementById('prixHT');
const elTTC  = document.getElementById('prixTTC');
const elMsg  = document.getElementById('msg');

/* ------- HELPERS ------- */
function num(v){
  const s = String(v ?? '').replace(/\u202F/g,'').replace(/\s/g,'').replace(',', '.');
  const m = s.match(/-?\d+(\.\d+)?/);
  return m ? parseFloat(m[0]) : NaN;
}
function normalizeKey(k){
  return String(k||'').toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/[^a-z0-9]+/g,'').trim();
}
function parseCSVAuto(text){
  text = String(text||'').replace(/^\uFEFF/, '').trim();
  const lines = text.split(/\r\n|\n|\r/).filter(l=>l.trim().length>0);
  if(!lines.length) return {rows:[], rawHeads:[], heads:[]};
  const first = lines[0];
  const sep = (first.match(/;/g)||[]).length > (first.match(/,/g)||[]).length ? ';' : ',';
  const rawHeads = first.split(sep).map(h=>h.replace(/^"+|"+$/g,'').trim());
  const heads = rawHeads.map(h=>normalizeKey(h));
  const rows = lines.slice(1).map(line=>{
    const cells = line.split(sep).map(c=>c.replace(/^"+|"+$/g,'').trim());
    const o={}; heads.forEach((h,i)=>o[h]=cells[i]??''); return o;
  });
  return { rows, rawHeads, heads };
}
function distinct(arr){ return [...new Set(arr)]; }
function uniqueSortedNumeric(arr){
  return [...new Set(arr)].map(num).filter(n=>!isNaN(n)).sort((a,b)=>a-b).map(String);
}
function isActive(v){
  const s = String(v||'').trim().toLowerCase();
  return ['true','1','oui','vrai','yes','y','x'].includes(s);
}

/* ------- AUTO-MAP ------- */
function autoMapTarifs(){
  const F = (arr, ...res)=> arr.find(k=>res.some(r=>r.test(k))) || null;
  MAP_T.type  = F(HEADS_T, /type/, /face/);
  MAP_T.h     = F(HEADS_T, /hauteur|height|hmm|h_mm|h/);
  MAP_T.l     = F(HEADS_T, /largeur|width|lmm|l_mm|l/);
  MAP_T.price = F(HEADS_T, /prix|base|eur|ht|price/);
  return MAP_T.type && MAP_T.h && MAP_T.l && MAP_T.price;
}
function autoMapOptions(){
  const F = (arr, ...res)=> arr.find(k=>res.some(r=>r.test(k))) || null;
  MAP_O.type  = F(HEADS_O, /type/, /option/);
  MAP_O.hmin  = F(HEADS_O, /hmin|hauteurmin|min/);
  MAP_O.hmax  = F(HEADS_O, /hmax|hauteurmax|max/);
  MAP_O.price = F(HEADS_O, /prix|ht|unitaire|price/);
  MAP_O.actif = F(HEADS_O, /actif|active|isactive|true|oui|vrai|1/);
  return MAP_O.type && MAP_O.hmin && MAP_O.hmax && MAP_O.price && MAP_O.actif;
}

/* ------- APPLY ------- */
function applyTarifs(){
  TARIFFS = RAW_TARIFFS.map(r=>({
    type: String(r[MAP_T.type] || '').trim(),
    h:    String(r[MAP_T.h]    || '').trim(),
    l:    String(r[MAP_T.l]    || '').trim(),
    priceBase: num(r[MAP_T.price]) || 0
  })).filter(r=>r.type && r.h && r.l);

  const types = [...new Set(TARIFFS.map(r=>r.type))].sort();
  elType.innerHTML = '<option value="">— sélectionnez —</option>' +
    types.map(t=>`<option value="${t}">${t}</option>`).join('');
  return types.length>0;
}
function applyOptions(){
  OPTIONS = RAW_OPTIONS.map(r=>({
    typeOption: String(r[MAP_O.type] || '').trim(),
    hmin: num(r[MAP_O.hmin]),
    hmax: num(r[MAP_O.hmax]),
    priceUnit: num(r[MAP_O.price]) || 0,
    actif: isActive(r[MAP_O.actif])
  }));
  return OPTIONS.length>0;
}

/* ------- UI ------- */
function populateHL(){
  const t = elType.value;
  const filtered = TARIFFS.filter(r => r.type === t);
  const H = uniqueSortedNumeric(filtered.map(r=>r.h));
  const L = uniqueSortedNumeric(filtered.map(r=>r.l));
  elH.innerHTML = '<option value="">— sélectionnez —</option>' + H.map(v=>`<option value="${v}">${v}</option>`).join('');
  elL.innerHTML = '<option value="">— sélectionnez —</option>' + L.map(v=>`<option value="${v}">${v}</option>`).join('');
}

function renderOptionsCheckboxes(){
  const families = distinct(OPTIONS.map(o=>o.typeOption)).filter(Boolean).sort();
  if(!families.length){
    elOptsBox.innerHTML = '<div class="opt-row"><em>Aucune option disponible.</em></div>';
    return;
  }
  const h = num(elH.value);
  const isValid = (fam)=>{
    if(!h) return false;
    const rows = OPTIONS.filter(o =>
      o.typeOption===fam &&
      !isNaN(o.hmin) && !isNaN(o.hmax) &&
      h>=o.hmin && h<=o.hmax &&
      o.actif
    );
    return rows.length>0;
  };

  elOptsBox.innerHTML = families.map(f=>{
    const ok = isValid(f);
    const note = ok ? '' : ` <span class="muted">(non dispo pour H=${elH.value||'—'})</span>`;
    return `
      <label class="opt-row">
        <input type="checkbox" name="opt" value="${f}" ${ok?'':'disabled'}>
        <span>${f}</span>${note}
      </label>
    `;
  }).join('');

  [...elOptsBox.querySelectorAll('input[name="opt"]')].forEach(cb=>{
    cb.addEventListener('change', compute);
  });

  if(!h){
    elMsg.textContent = "Choisis d’abord la hauteur pour activer les options.";
  }else{
    const valides = families.filter(f=>!elOptsBox.querySelector(\`input[value="\${f}"]\`)?.disabled);
    elMsg.textContent = \`Hauteur sélectionnée: \${elH.value} | Options valides: \${valides.join(', ') || 'aucune'}\`;
  }
}

/* ------- CALCUL ------- */
function priceBase(){
  const t = elType.value;
  const h = num(elH.value);
  const l = num(elL.value);
  if(!t||!h||!l) return 0;

  const row = TARIFFS.find(r =>
    r.type===t &&
    Math.abs(num(r.h)-h)<0.001 &&
    Math.abs(num(r.l)-l)<0.001
  );
  return row ? row.priceBase : 0;
}
function priceOptionsSum(){
  const checked = [...elOptsBox.querySelectorAll('input[name="opt"]:checked')].map(c=>c.value);
  if(!checked.length) return 0;
  const h = num(elH.value);
  return checked.reduce((sum, fam)=>{
    const rows = OPTIONS.filter(o => o.typeOption===fam && h>=o.hmin && h<=o.hmax && o.actif);
    if(!rows.length) return sum;
    const unit = Math.max(...rows.map(o=>o.priceUnit).filter(v=>!isNaN(v)));
    return sum + (isFinite(unit)?unit:0);
  }, 0);
}
function compute(){
  const base = priceBase();
  const opt  = priceOptionsSum();
  const qte  = Math.max(1, parseInt(elQte.value||'1',10));
  const totalHT  = (base + opt) * qte;
  const totalTTC = totalHT * (1+TVA);
  elHT.textContent  = totalHT.toFixed(2).replace('.', ',');
  elTTC.textContent = totalTTC.toFixed(2).replace('.', ',');
}

/* ------- FETCH UTIL ------- */
async function fetchFirst(urls){
  for(const u of urls){
    try{
      const r = await fetch(u, {cache:'no-store'});
      if(r.ok){
        const t = await r.text();
        return {url:u, text:t};
      }
    }catch(_) {}
  }
  throw new Error("Aucun des chemins testés n'a abouti.");
}

/* ------- CHARGEMENT ------- */
async function loadAll(){
  try{
    const [{url:usedT, text:txtT}, {url:usedO, text:txtO}] = await Promise.all([
      fetchFirst(CANDIDATES_TARIFS),
      fetchFirst(CANDIDATES_OPTIONS)
    ]);

    const pT = parseCSVAuto(txtT);
    const pO = parseCSVAuto(txtO);

    RAW_TARIFFS = pT.rows; RAW_HEADERS_T = pT.rawHeads; HEADS_T = pT.heads;
    RAW_OPTIONS = pO.rows; RAW_HEADERS_O = pO.rawHeads; HEADS_O = pO.heads;

    const okMapT = autoMapTarifs();
    const okMapO = autoMapOptions();
    if(!okMapT){ elMsg.textContent = "Impossible d’auto-mapper TARIFS. En-têtes: "+RAW_HEADERS_T.join(" | "); return; }
    if(!okMapO){ elMsg.textContent = "Impossible d’auto-mapper OPTIONS. En-têtes: "+RAW_HEADERS_O.join(" | "); return; }

    const okT = applyTarifs();
    const okO = applyOptions();
    if(!okT){ elMsg.textContent = "Aucune ligne de tarifs exploitable après mappage."; return; }

    elType.addEventListener('change', ()=>{ populateHL(); renderOptionsCheckboxes(); compute(); });
    elH.addEventListener('change',   ()=>{ renderOptionsCheckboxes(); compute(); });
    elL.addEventListener('change', compute);
    elQte.addEventListener('input', compute);

    populateHL();
    renderOptionsCheckboxes();
    compute();

    elMsg.textContent =
      `CSV chargés.\n` +
      `Tarifs: ${RAW_TARIFFS.length} lignes (via ${usedT})\n` +
      `Options: ${RAW_OPTIONS.length} lignes (via ${usedO})\n` +
      `En-têtes Tarifs: [${RAW_HEADERS_T.join(" | ")}]\n` +
      `En-têtes Options: [${RAW_HEADERS_O.join(" | ")}]`;
  }catch(e){
    elMsg.textContent = "Erreur de chargement : " + e.message;
    console.error(e);
  }
}

loadAll();
</script>
</body>
</html>
